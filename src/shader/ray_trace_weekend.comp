#version 460

// ------------- layout ------------- 

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(set = 0, binding = 0, rgba8) uniform image2D targetImage[8];

struct Sphere {
  vec3 center;
  float radius;
};

layout(set = 0, binding = 1) uniform GlobalUbo {
  vec3 origin;
  vec3 horizontal;
  vec3 vertical;
  vec3 lowerLeftCorner;
  Sphere spheres[2];
  int currentSample;
} ubo;

// ------------- pre-defined parameter -------------

float pi = 3.14159265359;

// ------------- struct ------------- 

struct Ray {
  vec3 origin;
  vec3 direction;
};

struct FaceNormal {
  bool frontFace;
  vec3 normal;
};

struct HitRecord {
  bool isHit;
  float t;
  vec3 point;
  FaceNormal faceNormal;
};

// ------------- function ------------- 

// Random number generation using pcg32i_random_t, using inc = 1. Our random state is a uint.
uint stepRNG(uint rngState) {
  return rngState * 747796405 + 1;
}

// Steps the RNG and returns a floating-point value between 0 and 1 inclusive.
float stepAndOutputRNGFloat(inout uint rngState) {
  // Condensed version of pcg_output_rxs_m_xs_32_32, with simple conversion to floating-point [0,1].
  rngState  = stepRNG(rngState);
  uint word = ((rngState >> ((rngState >> 28) + 4)) ^ rngState) * 277803737;
  word      = (word >> 22) ^ word;
  return float(word) / 4294967295.0;
}

float randomFloat(vec2 xy) {
  uint rngState =  (600 * xy.x + xy.y) * (ubo.currentSample + 1);
  return stepAndOutputRNGFloat(rngState);
}

float randomFloatAt(float min, float max, vec2 xy) {
  return min + (max - min) * random(xy);
}

vec3 randomVecThree(vec2 xy) {
  return vec3(randomFloat(xy), randomFloat(xy), randomFloat(xy));
}

vec3 randomVecThreeAt(float min, float max, vec2 xy) {
  return vec3(randomFloatAt(min, max, xy), randomFloatAt(min, max, xy), randomFloatAt(min, max, xy));
}

vec3 randomInUnitSphere(vec2 xy) {
  while (true) {
    vec3 p = randomVecThreeAt(-1.0, 1.0, xy);

    if (dot(p, p) >= 1) continue;
    return p;
  }
}

vec3 rayAt(Ray r, float t) {
  return r.origin + t * r.direction;
}

FaceNormal setFaceNormal(Ray r, vec3 outwardNormal) {
  FaceNormal faceNormal;

  faceNormal.frontFace = dot(r.direction, outwardNormal) < 0.0;
  faceNormal.normal = faceNormal.frontFace ? outwardNormal : -outwardNormal;

  return faceNormal;
}

HitRecord hitSphere(Sphere obj, Ray r, float tMin, float tMax) {
  FaceNormal faceNormal;
  faceNormal.frontFace = false;
  faceNormal.normal = vec3(0, 0, 0);

  HitRecord rec;
  rec.isHit = false;
  rec.t = 0.0;
  rec.point = vec3(0, 0, 0);
  rec.faceNormal = faceNormal;

  vec3 oc = r.origin - obj.center;

  float a = dot(r.direction, r.direction);
  float half_b = dot(oc, r.direction);
  float c = dot(oc, oc) - obj.radius * obj.radius;

  float discriminant = half_b * half_b - a * c;

  if (discriminant < 0.0) {
    return rec;
  }

  float sqrtd = sqrt(discriminant);

  // Find the nearest root that lies in the acceptable range.
  float root = (-half_b - sqrtd) / a;
  if (root < tMin || tMax < root) {
    root = (-half_b + sqrtd) / a;
    if (root < tMin || tMax < root) {
      return rec;
    }
  }

  rec.isHit = true;
  rec.t = root;
  rec.point = rayAt(r, rec.t);

  vec3 outwardNormal = (rec.point - obj.center) / obj.radius;
  rec.faceNormal = setFaceNormal(r, outwardNormal);

  return rec;
}

HitRecord hitSphereList(Sphere objList[2], int objNum, Ray r, float tMin, float tMax) {
  FaceNormal faceNormal;
  faceNormal.frontFace = false;
  faceNormal.normal = vec3(0, 0, 0);
  
  HitRecord rec;
  rec.isHit = false;
  rec.point = vec3(0, 0, 0);
  rec.faceNormal = faceNormal;

  rec.t = tMax;
  for (int i = 0; i < objNum; i++) {
    HitRecord tempRec = hitSphere(objList[i], r, tMin, rec.t);
    if (tempRec.isHit) {
      rec = tempRec;
    }
  }

  return rec;
}

vec3 rayColor(Ray r) {
  Ray curRay = r;
  float curAttenuation = 1.0;
  
  for(int i = 0; i < 50; i++) {
    HitRecord rec = hitSphereList(ubo.spheres, 2, curRay, 0.001, 10000.0);

    if (rec.isHit) {
      vec3 target = rec.point + rec.faceNormal.normal + normalize(randomInUnitSphere(gl_GlobalInvocationID.xy));
      curAttenuation *= 0.5f;

      curRay.origin = rec.point;
      curRay.direction = target - rec.point;

    } else {
      vec3 unit_direction = normalize(curRay.direction);
      float t = 0.5 * (unit_direction.y + 1.0);
      vec3 c = (1.0 - t) * vec3(1.0, 1.0, 1.0) + t * vec3(0.5, 0.7, 1.0);

      return curAttenuation * c;
    }
  }

  return vec3(0.0, 0.0, 0.0); // exceeded recursion
}

void main() {
  uint imgIndex = gl_GlobalInvocationID.z;
  vec2 imgPosition = gl_GlobalInvocationID.xy;

  vec2 imgSize = vec2(imageSize(targetImage[imgIndex]));

  float noiseX = randomFloat(gl_GlobalInvocationID.xz);
  float noiseY = randomFloat(gl_GlobalInvocationID.yz);

  vec2 noiseUV = vec2(noiseX, noiseY);
  vec2 uv = (imgPosition + noiseUV) / imgSize;

  Ray r;
  r.origin = ubo.origin;
  r.direction = ubo.lowerLeftCorner + uv.x * ubo.horizontal - uv.y * ubo.vertical - ubo.origin;
  
  vec4 curColor = vec4(rayColor(r), 1.0);
  imageStore(targetImage[imgIndex], ivec2(imgPosition), curColor);
}